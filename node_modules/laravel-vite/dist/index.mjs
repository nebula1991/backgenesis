// src/index.ts
import path2 from "path";
import { homedir } from "os";
import deepmerge from "deepmerge";
import execa from "execa";
import chalk from "chalk";
import dotenv from "dotenv";
import dotenvExpand from "dotenv-expand";
import makeDebugger from "debug";

// src/manifest-plugin.ts
import { createHash } from "crypto";
import fs from "fs/promises";
import path from "path";
function manifestPlugin() {
  const manifest = new Map();
  let config;
  return {
    name: "vite:laravel:manifest",
    apply: "build",
    enforce: "post",
    configResolved(resolved) {
      config = resolved;
    },
    async generateBundle(_, bundle) {
      const entrypoints = getEntrypoints(config);
      if (!entrypoints) {
        return;
      }
      const values = Object.values(bundle);
      const assets = values.filter((c) => c.type === "asset");
      const cssEntrypoints = entrypoints.filter((entry) => isStylesheet(entry));
      const cssAssets = assets.filter((asset) => isStylesheet(asset.name));
      if (config.build.cssCodeSplit) {
        for (const chunk of cssAssets) {
          if (!chunk.name) {
            continue;
          }
          const name = removeExtension(chunk.name);
          for (const entry of cssEntrypoints) {
            if (removeExtension(path.basename(entry)) === name) {
              manifest.set(entry, { file: chunk.fileName, src: entry, isEntry: true });
            }
          }
        }
      } else {
        const chunk = assets.find((asset) => asset.name === "style.css");
        if (chunk) {
          manifest.set(chunk.name, { file: chunk.fileName, src: chunk.name });
        }
      }
      const remaining = entrypoints.filter((entry) => isAssetEntrypoint(entry));
      for (const entry of remaining) {
        const fullPath = path.join(config.root, entry);
        const source = await fs.readFile(fullPath);
        const hash = getAssetHash(source);
        const ext = path.extname(entry);
        const name = removeExtension(entry);
        const fileName = path.posix.join(config.build.assetsDir, `${path.basename(name)}.${hash}${ext}`);
        manifest.set(entry, { file: fileName, src: entry, isEntry: true });
        if (!bundle[fileName]) {
          this.emitFile({ name: entry, fileName, source, type: "asset" });
        }
      }
    },
    async writeBundle(_opts, bundle) {
      if (!bundle["manifest.json"]) {
        return;
      }
      const manifestPath = path.resolve(config.root, config.build.outDir, "manifest.json");
      const viteManifest = JSON.parse(await fs.readFile(manifestPath, "utf8"));
      for (const [key, value] of Object.entries(viteManifest)) {
        manifest.set(key, value);
      }
      await fs.writeFile(manifestPath, JSON.stringify(Object.fromEntries(manifest), null, 2));
    }
  };
}
function getEntrypoints(config) {
  let input = config.build.rollupOptions.input;
  if (!input) {
    return null;
  }
  if (typeof input === "string") {
    input = [input];
  }
  if (typeof input === "object" && !Array.isArray(input)) {
    const keys = Object.keys(input);
    if (keys.length === 0) {
      return null;
    }
    input = keys;
  }
  if (input.length === 0) {
    return null;
  }
  return input.map((entry) => path.relative(config.root, entry));
}
function removeExtension(filename) {
  return filename.replace(/\.[^.]*$/, "");
}
function isStylesheet(filename) {
  return /\.(css|less|sass|scss|styl|stylus|pcss|postcss)$/.test(filename);
}
function isAssetEntrypoint(filename) {
  if (isStylesheet(filename)) {
    return false;
  }
  return !/\.(html|jsx?|tsx?)$/.test(filename);
}
function getAssetHash(content) {
  return createHash("sha256").update(content).digest("hex").slice(0, 8);
}

// src/index.ts
var debug = makeDebugger("vite:laravel");
var bladeReload = () => ({
  name: "vite:laravel:blade",
  handleHotUpdate({ file, server }) {
    if (file.endsWith(".blade.php") || file.endsWith("vite.php")) {
      server.ws.send({
        type: "full-reload",
        path: "*"
      });
    }
  }
});
var staticAssetFixer = (regex, replaceWith) => ({
  name: "static-asset-fixer",
  enforce: "post",
  apply: "serve",
  transform: (code) => ({
    code: code.replace(regex, replaceWith),
    map: null
  })
});
var ViteConfiguration = class {
  constructor(config = {}, artisan = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    dotenvExpand(dotenv.config());
    debug("Loaded configuration with dotenv");
    this.envPrefix = ["VITE_", "MIX_"];
    this.base = (_a = process.env.ASSET_URL) != null ? _a : "";
    if (!this.base.endsWith("/")) {
      this.base += "/";
    }
    if (((_b = process.env.NODE_ENV) == null ? void 0 : _b.startsWith("prod")) || process.env.APP_ENV !== "local") {
      debug("Running in production, adding build path to base");
      this.base += (_c = artisan.build_path) != null ? _c : "";
      if (!this.base.endsWith("/")) {
        this.base += "/";
      }
    }
    debug("Set base URL:", this.base);
    this.plugins = [];
    this.publicDir = (_d = artisan.public_directory) != null ? _d : "resources/static";
    this.build = {
      manifest: true,
      outDir: (artisan == null ? void 0 : artisan.build_path) ? `public/${artisan.build_path}` : "public/build",
      rollupOptions: {
        input: []
      }
    };
    debug("Set build configuration:", this.build);
    this.plugins.push(bladeReload());
    this.plugins.push(manifestPlugin());
    if (artisan == null ? void 0 : artisan.aliases) {
      this.resolve = {
        alias: Object.fromEntries(Object.entries(artisan.aliases).map(([alias, directory]) => {
          return [alias, path2.join(process.cwd(), directory)];
        }))
      };
      debug("Registered aliases:", this.resolve.alias);
    }
    if (artisan == null ? void 0 : artisan.dev_url) {
      const [protocol, host, port] = artisan.dev_url.split(":");
      this.server = {
        host: host.substr(2),
        https: protocol === "https",
        port: port ? Number(port) : 3e3,
        origin: `${protocol}:${host}:${port}`,
        hmr: {
          host: host.substr(2),
          port: Number(port) || 3e3
        }
      };
      debug("Configured server:", this.server);
      if (artisan == null ? void 0 : artisan.entrypoints) {
        this.build.rollupOptions.input.push(...artisan.entrypoints);
      }
      debug("Configured entrypoints:", this.build.rollupOptions.input);
      if (((_e = artisan == null ? void 0 : artisan.asset_plugin) == null ? void 0 : _e.find_regex) && ((_f = artisan == null ? void 0 : artisan.asset_plugin) == null ? void 0 : _f.replace_with)) {
        const regex = new RegExp((_g = artisan == null ? void 0 : artisan.asset_plugin) == null ? void 0 : _g.find_regex, "g");
        const replace = artisan.dev_url + ((_h = artisan == null ? void 0 : artisan.asset_plugin) == null ? void 0 : _h.replace_with);
        this.plugins.push(staticAssetFixer(regex, replace));
        debug("Registered asset-fixing plugin:", { regex, replace });
      }
      this.merge(config);
    }
    if (artisan == null ? void 0 : artisan.commands) {
      for (const command of artisan.commands) {
        const parts = Array.isArray(command) ? command : [command];
        debug("Running:", parts.join(" "));
        debug(callArtisan(...parts));
      }
    }
  }
  withValetCertificates(options) {
    var _a, _b, _c;
    const home = homedir();
    const domain = (_b = options == null ? void 0 : options.domain) != null ? _b : (_a = process.env.APP_URL) == null ? void 0 : _a.replace(/^https?:\/\//, "");
    let path3 = (_c = options == null ? void 0 : options.path) != null ? _c : "/.config/valet/Certificates/";
    if (!domain) {
      console.warn("No domain specified. Certificates will not be applied.");
      return this;
    }
    if (!path3.endsWith("/")) {
      path3 = `${path3}/`;
    }
    return this.withCertificates(`${home}${path3}${domain}.key`, `${home}${path3}${domain}.crt`);
  }
  withLaragonCertificates(path3) {
    path3 != null ? path3 : path3 = "C:\\laragon";
    if (path3.endsWith("\\")) {
      path3 = path3.slice(0, -1);
    }
    return this.withCertificates(`${path3}\\etc\\ssl\\laragon.key`, `${path3}\\etc\\ssl\\laragon.crt`);
  }
  withCertificates(callbackOrKey, cert) {
    if (!callbackOrKey && !cert) {
      callbackOrKey = process.env.DEV_SERVER_KEY;
      cert = process.env.DEV_SERVER_CERT;
    }
    if (typeof callbackOrKey === "function") {
      [callbackOrKey, cert] = callbackOrKey(process.env);
    }
    if (!callbackOrKey && !cert) {
      console.warn(chalk.yellow.bold('(!) Certificates are not configured properly. Ensure your environment file is has "DEV_SERVER_KEY" and "DEV_SERVER_CERT".'));
      return this;
    }
    return this.merge({
      server: {
        https: {
          maxVersion: "TLSv1.2",
          key: callbackOrKey,
          cert
        }
      }
    });
  }
  withPostCSS(plugins = []) {
    return this.merge({
      css: {
        postcss: {
          plugins
        }
      }
    });
  }
  withStaticAssets(publicDir) {
    this.publicDir = publicDir;
    return this;
  }
  withOutput(outDir) {
    this.build.outDir = outDir;
    return this;
  }
  withEntry(...entries) {
    throw new Error("Adding entrypoints via vite.config.ts is no longer supported, use config/vite.php instead.");
    return this;
  }
  withEntries(...entries) {
    return this.withEntry(...entries);
  }
  withPlugin(plugin) {
    if (typeof plugin === "function") {
      plugin = plugin();
    }
    this.plugins.push(plugin);
    return this;
  }
  withPlugins(...plugins) {
    plugins.forEach((plugin) => this.withPlugin(plugin));
    return this;
  }
  merge(config) {
    if (typeof config === "function") {
      config = config(process.env);
    }
    const result = deepmerge(this, config);
    if (Reflect.has(config, "base")) {
      console.warn(chalk.yellow.bold('(!) "base" option should not be used with Laravel Vite. Use the "ASSET_URL" environment variable instead.'));
    }
    for (const [key, value] of Object.entries(result)) {
      this[key] = value;
    }
    debug("Merged configuration", config);
    return this;
  }
};
function getConfigurationFromArtisan() {
  try {
    return JSON.parse(callArtisan("vite:config"));
  } catch (error) {
    console.warn("Could not read configuration from PHP.");
    console.error(error);
  }
}
function callArtisan(...params) {
  var _a;
  return (_a = execa.sync("php", ["artisan", ...params])) == null ? void 0 : _a.stdout;
}
function createViteConfiguration() {
  return defineConfig();
}
function defineConfig(config = {}, artisan) {
  return new ViteConfiguration(config, artisan != null ? artisan : getConfigurationFromArtisan());
}
var src_default = defineConfig;
export {
  ViteConfiguration,
  bladeReload,
  callArtisan,
  createViteConfiguration,
  src_default as default,
  defineConfig,
  staticAssetFixer
};
